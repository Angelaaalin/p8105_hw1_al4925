---
title: "p8105_hw1_al4925"
author: "Angela Lin"
date: "2025-09-20"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Problem 1
```{r} 
library(moderndive)
library(tidyverse)
data("early_january_weather")
names(early_january_weather)
nrow(early_january_weather)
ncol(early_january_weather)
mean(early_january_weather$temp, na.rm = TRUE)
```

The "early_january_weather" records hourly meteorological data for LGA, JFK and EWR for the month of January 2013. This is a subset of the weather data frame from nycflights13. This dataser contains 358 rows representing hourly measuremnets and 15 variables. The variables includes origin, year, month, day, hour, temperature, dewpoint in Fahrenheit, humid, wind direction (in degrees), speed and gust speed (in degree), precipiation in inches, pressure in millibars, visibility in miles, and the recording date and hour. Overall, the mean temperature is around 39.58 F.

```{r}
temp_plot<- ggplot(early_january_weather, aes(x = time_hour, y = temp)) +
  geom_point(aes(color = humid)) +
  labs(title = "NYC Temperature vs Time in Early January 2013",
       x = "Time", 
       y = "Temperature",
       color = "Humidity")
temp_plot
ggsave("ggp_temp.pdf", temp_plot, width = 8, height = 5 )

```

In early January 2013, the temperature started in the 30 to low 40 F, and it climbed to mid-50 F, then drop again. While the temperature is overall growing, there is a daily wiggle, which may be cooler at night/morning and warmer in the afternoon. The lighter dots represents higher humidity during the warm stretch, while the darker dots represents the cooler hour with the lower humidity. Generally, the warmer periods tends to be more humid, but humidity could change due to the daily temperature wiggling. 

## Problem 2
```{r}
number<- rnorm(10)
logical<- number > 0
character<- letters[1:10]
factor<- factor(rep(c("low", "medium", "high"), levels = c("low", "medium", "high"), length = 10))

df<- tibble(number, logical, character, factor)
df
mean(df$number)
mean(df$logical)
mean(df$character)
mean(df$factor)
 
```

In this case, mean works in `number` because it is numeric. Mean works in `logical` because R defines `TRUE` as 1 and `FALSE` as 0. Therefore, the mean is the proportion of the `TRUE`. Mean does not work in `character` because they are not numeric, and it returns `NA`. Mean also does not work in `factor` because they are categorical, and it returns `NA` as well. 

```{r}
as.numeric(df$number)
as.numeric(df$logical)
as.numeric(df$character)
as.numeric(df$factor)

```

Now, we apply `as.numeric()` function to each variables. `number` remains unchanged because they are originally numeric. `logical` changes from `TURE`/`FALSE` to 1/0. `character` returns `NA` because they are not numeric or ordered by levels. `factor` returns 1 to 3, aligning with the levels from "low", "medium", and "high", which given the level order we set in the origical code. Among four variables, `as.numeric()` explains why `logical` can get a mean even though they don't "look numeric". It is all because R set `TRUE` to 1 and `FALSE` to 0. And `factor` can only get the mean if we use `as.numeric()` function to change their levels into numeric order.
